### 前置知识
  - js执行是单线程操作
      - 同步
      - 异步
  - 解决阻塞
  - 异步操作
  - javaScript引擎是单线程的
    - 这样就不会存在任务见间的相互影响：
        举个反列如果是多线程的情况下，同时两个任务，当任务A要删除一个DOM节点，任务B要去修改该节点的属性，这样是有问题的
    - 由于是单线程执行，必然会存在代码长时间阻塞的情况，这时浏览器页面会卡斯，为了提高执行效率和用户体验，js实现异步执行
    - 如何在单线程中实现异步执行了？
      - 是通过的事件循环(event loop),以下三步循环执行,这就是event loop---理解了event loop机制,就理解了JS的执行机制
      1. 首先判断JS是同步还是异步,同步就进入主进程,异步就进入event table
      2. 异步任务在event table中注册函数,当满足触发条件后,被推入event queue
      3. 同步任务进入主线程后一直执行,直到主线程*空闲时*,才会去event queue中查看是否有可执行的异步任务,如果有就推入主进程中
```

--------------------------------------------------------------------------
js 线程      |   执行本轮其他任务                     | 执行回调
--------------------------------------------------------------------------
            |                                    /|\
            |                                     |
           \|/                                    |
      发起异步调用                               |----------------------------
            |             事件列队 event queue  | 回调1, 回调2, 回调3, 回调4···
            |                                  |----------------------------
                                                                       /|\
            |                                                           |
            |                                                           |
            |                                                           |
            |          ------------异步回调排队----------------------------
            |          |
           \|/         |
--------------------------------------------------------------------------
异步调用线程  |执行异步任务|
event table |          |
--------------------------------------------------------------------------


```


### 内容概要
  - 同步模式与异步模式
  - 时间循环与消息列队
  - 异步编程的方式
  - Promise异步方案、宏任务/微任务列队
  - Generator异步方案、Async/Await语法糖（扁平的异步代码）

### 回调函数
  - 回掉地狱
  - promise
      - 概念
      - 应用
      - 链式调用 （如何实现）
      - Promise 对象的 then 方法返回一个全新的 Promise 对象
          - then(fn, fn2)
      - Promise 对象的 catch
      - 静态方法
        - Promise.resolve() => Promise 对象
            - thenable => promise ?
        - Promise.reject() => Promise 对象
        - Promise.all
        - Promise.race
      - Promise  执行时序
  - Generator 生成器函数 =》 生成器对象
